# Создание нового модуля {#modules}

С ростом вашего веб-сайта вам может пригодиться такая особенность Laminas Framework, как *модули (modules)*.
Модульные приложения состоят из частей, имеющих относительно небольшое количество зависимостей
друг от друга. Это позволяет устанавливать или удалять модули по мере необходимости. В этой главе
вы узнаете о том, что такое модули, а также когда и как их создавать.

## Когда создавать новый модуль?

Модуль - это *автономный* блок вашего приложения с возможностью *повторного использования*. По умолчанию,
приложение имеет только модуль *Application*. Помещать свои модели, представления и контроллеры в этот
модуль - вполне нормально, особенно при разработке простого веб-сайта.

I> Модуль может содержать модели, представления, контроллеры и ресурсы. Классы модулей, как правило, "живут"
I> в отдельном пространстве имен (с тем же именем, что и у модуля). У модуля есть свой файл конфигурации, где
I> можно зарегистрировать маршруты, контроллеры, плагины контроллеров, сервисы, помощники представлений и т.д.

Вам может понадобиться создать новый модуль в следующих случаях:

  * Если ваш веб-сайт относительно больших размеров, и его будет проще поддерживать, разбив на части.
    Например, вы можете ввести модуль *Admin* и поместить в него функциональность бэк-энда.
  * Если реализуемая вами функциональность автономна (не имеет или имеет малое количество зависимостей
    от других модулей приложения). Например, функциональность Blog теоретически может быть
    выделена в отдельный модуль, так как она не зависит от остальной части приложения (но
    приложение от нее зависит).
  * Если модуль можно отделить от вашего приложения и одновременно использовать в другом проекте.
    Например, модуль Blog можно повторно использовать в другом проекте, не меняя его (изменения
    могут потребоваться только для конфигурации модуля).

В любом случае, в реальной жизни все несколько сложнее, и вы должны руководствоваться интуицией,
когда принимаете решение о создании нового модуля. Если вам кажется, что выделение функциональности
в отдельный модуль принесет вам значительную пользу, стоит его создать.

В то же время, не следует создавать большое количество почти пустых модулей - лучше объединять
в один модуль функционально связанные между собой элементы.

## Как создать новый модуль?

Существует по меньшей мере два способа создания нового модуля. Первый - скопировать существующий модуль
из каталога *APP_DIR/module* (например, *Application*), удалить все ненужные контроллеры, модели и представления
и изменить имя существующего пространства имен на имя вашего модуля в каждом исходном файле. Это может быть
довольно скучным занятием.

Второй способ - скачать пустой *скелетный модуль* с официального репозитория Laminas Framework на GitHub.
Его можно найти по [этой ссылке](https://github.com/laminas/LaminasSkeletonModule).
Вы можете либо скопировать код, либо (что рекомендуется) скачать его в виде ZIP-архива.

Например, в Linux, для загрузки скелетного модуля используются следующие команды:

~~~
cd ~
wget https://github.com/laminas/LaminasSkeletonModule/archive/master.zip
unzip master.zip
cp LaminasSkeletonModule-master APP_DIR/module/LaminasSkeletonModule
~~~

Эти команды скачивают исходный код скелетного модуля в ваш домашний каталог, распаковывают
архив и копируют файлы в каталог `module` вашего веб-сайта.

Давайте посмотрим на структуру скелетного модуля (см. рисунок 14.1)

![Рисунок 14.1. Структура каталогов скелетного модуля](../en/images/modules/skeleton_module_directory.png)

Как видите, скелетный модуль имеет типичную структуру каталогов, с которой мы уже знакомы:

  * подкаталог `config` содержит файл `module.config.php` - файл конфигурации для этого модуля.
  * подкаталог `src` - это каталог, содержащий исходные файлы модуля:
    * подкаталог `Controller` содержит образец класса контроллера.
    * файл `Module.php` - это точка входа в модуль. Мы поговорим о нем немного позже.
  * подкаталог `tests` содержит функции-заглушки для юнит-тестирования. В этой книге в целях упрощения мы не рассматриваем юнит-тестирование.
  * подкаталог `view` содержит скрипты видов (и также может содержать шаблоны лэйаутов для конкретного модуля).

### Переименование скелетного модуля

Перед тем, как начать использовать созданный нами модуль, нужно выбрать для него имя. Хорошее имя должно описывать
модуль. Например, имя `Admin` - неплохой вариант, если вам нужен модуль для бэк-энда. Имя `Blog` подойдет, если в
этом модуле вы планируете хранить функциональность блога. Кроме того, перед именем модуля стоит добавлять название
компании , например, `YourCompanyBlog`.

После того, как вы выбрали имя для модуля, нужно переименовать каталог, содержащий его файлы. Например, команда
ниже переименует модуль в `Admin`:

~~~
mv LaminasSkeletonModule Admin
~~~

Затем нужно переименовать `SkeletonController.php` во что-то более наглядное. Не забудьте также переименовать подкаталоги
каталога `view` так, чтобы они отражали имя контроллера.

Наконец, пройдите по файлам конфигурации и исходного кода контроллера и убедитесь, что вы изменили имя пространства имен
`LaminasSkeletonModule` на имя вашего модуля (это необходимо для обеспечения того, что ваши классы будут найдены автозагрузчиком классов PHP).

### Включение автозагрузки классов

Последним шагом будет включение автозагрузки PHP-классов. Наши исходные файлы модуля будут организованы таким образом, чтобы
соответствовать стандарту PSR-4, так что мы сможем использовать стандартный автозагрузчик, предоставляемый Composer'ом. Для
этого добавьте следующую строку под ключ `psr-4` в файле `composer.json` (если у вас другое имя модуля, замените Admin на него):

~~~
...
"autoload": {
        "psr-4": {
            ...
            "Admin\\": "module/Admin/src/"
        }
    },
...
~~~

Затем запустите следующую команду для того, чтобы Composer обновил свои файлы автозагрузки:

~~~
php composer.phar dump-autoload
~~~

I> Команда Composer'а `dump-autoload` просто регенерирует код автозагрузчика без установки/обновления зависимостей.

Отлично! Теперь модуль готов к использованию. Вы можете добавить в него контроллеры, модели и представления. Не забудьте
изменить файл `module.config.php` и зарегистрировать маршруты, сервисы, контроллеры, плагины контроллеров, помощники
представлений и т.д.

### Включение модуля

Чтобы дать знать Laminas о новом модуле и чтобы он загрузился при старте приложения, не забудьте включить созданный модуль в
файле *APP_DIR/config/modules.config.php*, как показано ниже:

~~~
return [
    'Admin',
    //...
);
~~~

## Файл Module.php и обработка событий

Файл `Module.php`, расположенный внутри корневого каталога модуля, является своего рода *точкой входа* модуля.
Класс `Module`, который определяется в этом файле, загружается компонентом `Laminas\ModuleManager` при загрузке
всех модулей приложения.

С этим классом можно сделать одну полезную вещь - *зарегистрировать обработчики событий*. Если помните из главы [Как работает веб-сайт](#operation),
у приложения есть жизненный цикл, представленный событиями. Вы можете написать функцию-обработчик событий (или класс) и
зарегистрировать ее в точке входа модуля. Когда вызывается событие, будет вызван ваш метод-обработчик (или же класс), позволяющий вам
сделать что-то полезное.

Q> **Зачем мне регистрировать обработчик событий?**
Q>
Q> Вот несколько практических примеров обработки событий, которые могут вам пригодиться:
Q>
Q>   * Обрабатывать событие *Route* для того, чтобы использовать безопасное соединение HTTPS.
Q>   * Когда ваш сайт находится в режиме обслуживания, обрабатывать событие *Route* для перехвата всех запросов и перенаправления пользователя.
Q>   * Обрабатывать событие *Dispatch*, чтобы перенаправить пользователя на другую страницу. Например, если пользователь не аутентифицирован, перенаправить его на страницу входа.
Q>   * Обрабатывать событие *Dispatch* для переопределения шаблона лэйаута по умолчанию для всех контроллеров, принадлежащих модулю.
Q>   * Обрабатывать событие *Dispatch Error* для сообщения об исключении или ошибке и/или их логирования.
Q>   * Обрабатывать событие *Render* для изменения содержимого получившейся веб-страницы..

Существует два способа зарегистрировать обработчик событий внутри класса `Module`: либо с помощью метода `init()` класса `Module`, либо с помощью
его другого метода, `onBootstrap()`. Разница между ними в том, что `init()` вызывается раньше, чем `onBootstrap()`, до инициализации всех
модулей, в то время как `onBootstrap()` вызывается тогда, когда все модули инициализированы. В последующих примерах мы используем метод `init()`.

### Пример 1. Переключение шаблона лэйаута

Чтобы показать, как подписаться на событие, создадим обработчик, который будет реагировать на событие
*Dispatch* и устанавливать другой шаблон лэйаута для *всех* контроллеров модуля:

~~~php
<?php
namespace YourCompanyModule;

use Laminas\ModuleManager\ModuleManager;
use Laminas\Mvc\MvcEvent;

class Module
{
    // Метод "init" вызывается при запуске приложения и
    // позволяет зарегистрировать обработчик событий.
    public function init(ModuleManager $manager)
    {
        // Получаем менеджер событий.
        $eventManager = $manager->getEventManager();
        $sharedEventManager = $eventManager->getSharedManager();
        // Регистрируем метод-обработчик.
        $sharedEventManager->attach(__NAMESPACE__, 'dispatch',
                                    [$this, 'onDispatch'], 100);
    }

    // Обработчик события.
    public function onDispatch(MvcEvent $event)
    {
        // Получаем контроллер, к которому был отправлен HTTP-запрос.
        $controller = $event->getTarget();
        // Получаем полностью определенное имя класса контроллера.
        $controllerClass = get_class($controller);
        // Получаем имя модуля контроллера.
        $moduleNamespace = substr($controllerClass, 0, strpos($controllerClass, '\\'));

        // Переключаем лэйаут только для контроллеров, принадлежащих нашему модулю.
        if ($moduleNamespace == __NAMESPACE__) {
            $viewModel = $event->getViewModel();
            $viewModel->setTemplate('layout/layout2');
        }
    }

    // ...
}
~~~

Во фрагменте кода выше мы добавляем в класс `Module` метод `init()`. В этом методе мы регистрируем обработчик события (строка 17)
с помощью метода `attach()`, предоставляемого классом `Laminas\EventManager\SharedEventManager`. Метод `attach()` принимает четыре
аргумента: ID компонента, являющегося источником события, имя события ("dispatch"), обработчик события (метод текущего класса
`onDispatch()`) и приоритет (100)).

Метод `onDispatch()` вызывается при событии Dispatch. В этом методе мы проверяем (строка 32), отправлен ли HTTP-запрос
контроллеру, принадлежащему нашему модулю, и, если это так, переключаем шаблон лэйаута (строка 34).

### Пример 2. Использование HTTPS

В этом примере мы покажем, как зарегистрировать обработчик событий, благодаря которому ваш сайт всегда будет использовать
HTTPS-соединение для всех веб-страниц:

~~~php
<?php
namespace YourCompanyModule;

use Laminas\ModuleManager\ModuleManager;
use Laminas\Mvc\MvcEvent;

class Module
{
    // Метод "init" вызывается при запуске приложения и
    // позволяет зарегистрировать обработчик событий.
    public function init(ModuleManager $manager)
    {
        // Получаем менеджер событий.
        $eventManager = $manager->getEventManager();
        $sharedEventManager = $eventManager->getSharedManager();
        // Регистрируем метод-обработчик.
        $sharedEventManager->attach(__NAMESPACE__, 'route',
                                    [$this, 'onRoute'], 100);
    }

    // Обработчик события.
    public function onRoute(MvcEvent $event)
    {
        if (php_sapi_name() == "cli") {
            // Не выполняем перенаправление на HTTPS в консольном режиме.
            return;
        }

        // Получаем URI запроса
        $uri = $event->getRequest()->getUri();
        $scheme = $uri->getScheme();
        // Если схема - не HTTPS, перенаправляем на тот же URI, но
        // со схемой HTTPS.
        if ($scheme != 'https'){
            $uri->setScheme('https');
            $response=$event->getResponse();
            $response->getHeaders()->addHeaderLine('Location', $uri);
            $response->setStatusCode(301);
            $response->sendHeaders();
            return $response;
        }
    }

    // ...
}
~~~

В этом коде мы регистрируем метод обработчика события, который вызывается при событии *Route*.

Внутри обработчика мы сначала проверяем, работает ли наш сайт в консольном режиме. В этом режиме
мы не выполняем перенаправление на HTTPS.

После этого мы извлекаем из HTTP-запроса URI и проверяем, является ли текущая схема HTTPS или нет.
Если нет, мы перенаправляем пользователя на тот же URL, но со схемой HTTPS.

### Пример 3. Сообщения об исключениях на веб-сайте

С помощью данной процедуры можно легко отслеживать все происходящие на сайте исключения. Сообщать
об исключениях или ошибках довольно важно, так как это позволяет сделать сайт более стабильным и безопасным,
а также улучшить взаимодействие с пользователем.

~~~php
<?php
namespace YourCompanyModule;

use Laminas\ModuleManager\ModuleManager;
use Laminas\Mvc\MvcEvent;

class Module
{
    // Метод "init" вызывается при запуске приложения и
    // позволяет зарегистрировать обработчик событий.
    public function init(ModuleManager $manager)
    {
        // Получаем менеджер событий.
        $eventManager = $manager->getEventManager();
        $sharedEventManager = $eventManager->getSharedManager();
        // Регистрируем метод-обработчик.
        $sharedEventManager->attach(__NAMESPACE__, MvcEvent::EVENT_DISPATCH_ERROR,
                                    [$this, 'onError'], 100);
        $sharedEventManager->attach(__NAMESPACE__, MvcEvent::EVENT_RENDER_ERROR,
                                    [$this, 'onError'], 100);
    }

    // Обработчик события.
    public function onError(MvcEvent $event)
    {
        // Получаем информацию об исключении.
        $exception = $event->getParam('exception');
        if ($exception!=null) {
            $exceptionName = $exception->getMessage();
            $file = $exception->getFile();
            $line = $exception->getLine();
            $stackTrace = $exception->getTraceAsString();
        }
        $errorMessage = $event->getError();
        $controllerName = $event->getController();

        // Подготавливаем сообщение эл. почты.
        $to = 'admin@yourdomain.com';
        $subject = 'Your Website Exception';

        $body = '';
        if(isset($_SERVER['REQUEST_URI'])) {
            $body .= "Request URI: " . $_SERVER['REQUEST_URI'] . "\n\n";
        }
        $body .= "Controller: $controllerName\n";
        $body .= "Error message: $errorMessage\n";
        if ($exception!=null) {
            $body .= "Exception: $exceptionName\n";
            $body .= "File: $file\n";
            $body .= "Line: $line\n";
            $body .= "Stack trace:\n\n" . $stackTrace;
        }

        $body = str_replace("\n", "<br>", $body);

        // Посылаем эл. сообщение об ошибке.
        mail($to, $subject, $body);
    }

    // ...
}
~~~

В данном фрагменте мы регистрируем обработчик событий, который будет вызываться при каждой
ошибке отправки запроса (при несоответствии маршрута или исключении) и ошибке визуализации.
Внутри метода обработчика `onError()` мы извлекаем информацию об исключении/ошибке и посылаем
ее в виде электронного сообщения на адрес по вашему выбору.

## Регистрация модуля в качестве пакета Composer'a

Если вы разрабатываете модуль с возможностью повторного использования, который вы затем планируете сделать общедоступным,
вы, возможно, захотите опубликовать код вашего модуля на GitHub и зарегистрировать в каталоге [Packagist.org](http://packagist.org)
как пакет, устанавливаемый Composer'ом. Это делается абсолютно бесплатно.

После регистрации пакета вы сможете добавить его к вашему веб-приложению в качестве зависимости следующим образом (замените
плейсхолдеры `vendor` и `package` на, соответственно, название вашей компании и имя пакета):

~~~
php composer.phar require vendor/package
~~~

Composer скачает и установит ваш модуль в каталог `vendor`. Таким образом, вы сможете использовать его, как любой другой
сторонний модуль.

## Выводы

В этой главе вы узнали о концепции *модулей* в Laminas Framework. Модуль - это *автономный* блок вашего приложения с
возможностью *повторного использования*. Модули стоит создавать, когда ваш веб-сайт вырастает до больших размеров, а
также, когда какая-либо функциональность имеет малое количество зависимостей от других частей приложения.

Каждый модуль Laminas имеет класс точки входа, называемый `Module`. Этот класс можно использовать для регистрации
обработчиков событий. Обработчики событий полезны, когда вы, например, хотите выбрать другой шаблон лэйаута по умолчанию
для всего модуля или изменить стандартное содержимое веб-страницы.

Если вы разрабатываете модуль, который хотите сделать общедоступным для использования в других проектах, можете зарегистрировать
его в каталоге Packagist.org и установить с помощью Composer в качестве стороннего пакета.
