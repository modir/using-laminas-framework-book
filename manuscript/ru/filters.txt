# Преобразование входных данных с помощью фильтров {#filters}

В этой главе мы рассмотрим стандартные фильтры, которые можно использовать для веб-форм.
Фильтр - это класс, который принимает входные данные, обрабатывает их и создает выходные данные.
Кроме этого, мы покажем, как написать свой собственный фильтр.

I> В целом, фильтры можно использовать даже *вне* форм для обработки произвольных данных.
I> Например, вы можете использовать фильтры в действии контроллера для преобразования данных,
I> переданных в качестве переменных GET и/или POST, в определенный формат.

Компоненты Laminas, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| @`Laminas\Filter`                  | Содержит различные классы фильтров.                           |
|--------------------------------|---------------------------------------------------------------|
| @`Laminas\InputFilter`             | Реализует контейнер для фильтров/валидаторов.                 |
|--------------------------------|---------------------------------------------------------------|

## О фильтрах

Фильтры предназначены для приема входных данных, их обработки, а затем создания выходных данных.
Laminas Framework предоставляет множество стандартных фильтров, которые можно использовать для создания
правил фильтрации ваших форм (или, если хотите, для фильтрации произвольных данных вне форм).

### FilterInterface

Технически, *фильтр* - это PHP-класс, реализующий интерфейс @`FilterInterface`[Laminas\Filter\FilterInterface] (он принадлежит
пространству имен @`Laminas\Filter`). Определение интерфейса представлено ниже:

{line-numbers=on, lang=php}
~~~
<?php
namespace Laminas\Filter;

interface FilterInterface
{
    // Возвращает результат фильтрации $value.
    public function filter($value);
}
~~~

Как видите, интерфейс @`FilterInterface`[Laminas\Filter\FilterInterface] имеет один единственный метод `filter()` (строка 7), который
принимает один параметр `$value`. Этот метод преобразовывает входные данные и затем возвращает получившееся
(отфильтрованное) значение.

T> В отдельных случаях класс фильтра, реализующий интерфейс @`FilterInterface`[Laminas\Filter\FilterInterface], может иметь и другие методы.
T> Например, у большого количества классов есть методы для конфигурации фильтра (задания опций фильтрации).

## Обзор стандартных фильтров

Стандартные фильтры, реализующие интерфейс @`FilterInterface`[Laminas\Filter\FilterInterface], принадлежат компоненту @`Laminas\Filter` [^стандартные_фильтры].
Диаграмма наследования классов фильтров показана на рисунке 8.1. Как видите из рисунка, базовый класс для большинства
стандартных фильтров - класс @`AbstractFilter`, реализующий интерфейс @`FilterInterface`[Laminas\Filter\FilterInterface] [^наследование_фильтров]

![Figure 8.1. Наследование классов фильтров](../en/images/filters/filter_inheritance.png)

[^стандартные_фильтры]: В этом разделе мы считаем стандартными только те фильтры, которые принадлежат пространству имен @`Laminas\Filter`,
              однако существуют и другие фильтры, которые можно считать стандартными. Например, пространство имен @`Laminas\Filter\File`[Laminas\Filter]
			  содержит несколько фильтров, применимых для обработки загрузок файлов (эти фильтры будут рассмотрены в следующих разделах).
			  Кроме этого, компонент @`Laminas\I18n` определяет несколько классов фильтров, которые осведомлены о локали (региональных настройках) пользователя).


[^наследование_фильтров]: Из рисунка выше также можно заметить, что существует еще несколько базовых фильтров: @`AbstractUnicode` - базовый класс
              для фильтров @`StringToUpper` и @`StringToLower`, так как он предоставляет общий для обоих набор функций для преобразования строк.
			  Фильтр @`Decompress` наследуется от фильтра @`Compress`, так как эти фильтры, на самом деле, очень похожи. Аналогично, фильтр @`Decrypt`[Laminas\Filter\Decrypt]
			  наследуется от фильтра @`Encrypt`[Laminas\Filter\Encrypt], потому что они тоже являются *зеркальными отражениями* друг друга.

I> Вы могли заметить странный фильтр @`StaticFilter`, который не наследуется от базового класса
I> @`AbstractFilter`. Это потому, что класс @`StaticFilter` на самом деле являются "оберткой" (то есть,
I> "заместителем" (proxy) для другого фильтра без явного инстанцирования второго).

Стандартные фильтры, предоставляемые компонентом @`Laminas\Filter`, вместе с их кратким описанием перечислены в таблице 8.1.

Как видите из этой таблицы, стандартные фильтры можно приблизительно разделить на следующие группы:

 * Фильтры для приведения типов входных данных (integer, boolean, дата/время и пр.);
 * фильтры, обрабатывающие путь файла (получение имени базы, имени родительской директории и т.д.);
 * фильтры, осуществляющие сжатие и шифрование входных данных;
 * фильтры, управляющие строковыми данными (изменение регистра, удаление пробелов, замена и удаление символов, нормализация URL и д.р.); и
 * фильтры-заместители - обертки для других фильтров (@`Callback`[Laminas\Filter\Callback], @`FilterChain`[Laminas\Filter\FilterChain] и @`StaticFilter`).

{title="Таблица 8.1. Стандартные фильтры"}
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| @`Boolean`[Laminas\Filter\Boolean]                    | Возвращает булевое представление `$value`.                    |
|--------------------------------|---------------------------------------------------------------|
| @`ToInt`                        | Приводит входные данные `$value` к типу `int`.               |
|--------------------------------|---------------------------------------------------------------|
| @`Digits`[Laminas\Filter\Digits]                       | Возвращает строку `$value`, удаляя все символы кроме цифр.    |
|--------------------------------|---------------------------------------------------------------|
| @`ToNull`                       | Возвращает `null`, если значение входных данных может трактоваться как null; иначе возвращает `$value`. |
|--------------------------------|---------------------------------------------------------------|
| @`DateTimeFormatter`            | Принимает строку даты/времени в произвольном формате и создает строку даты/времени в заданном формате. |
|--------------------------------|---------------------------------------------------------------|
| @`BaseName`                     | Принимая строку, содержащую путь к файлу или каталогу, этот фильтр вернет последний компонент имени. |
|--------------------------------|---------------------------------------------------------------|
| @`Dir`                          | Принимая строку, содержащую путь к файлу или каталогу, этот фильтр вернет путь родительского каталога. |
|--------------------------------|---------------------------------------------------------------|
| @`RealPath`                     | Возвращает каноническое абсолютное имя пути.                  |
|--------------------------------|---------------------------------------------------------------|
| @`Compress`                     | Сжимает входные данные с помощью указанного алгоритма (по умолчанию GZ). |
|--------------------------------|---------------------------------------------------------------|
| @`Decompress`                   | Разжимает входные данные с помощью указанного алгоритма (эффект противоположен фильтру `Compress`). |
|--------------------------------|---------------------------------------------------------------|
| @`Encrypt`[Laminas\Filter\Encrypt]                      | Зашифровывает входные данные указанным алгоритмом шифрования. |
|--------------------------------|---------------------------------------------------------------|
| @`Decrypt`[Laminas\Filter\Decrypt]                      | Расшифровывает входные данные, зашифрованные указанным алгоритмом шифрования. |
|--------------------------------|---------------------------------------------------------------|
| @`Inflector`                    | Изменяет слово для выражения различных грамматических категорий: времени, наклонения, залога, вида глагола, лица, числа, пола и падежа. |
|--------------------------------|---------------------------------------------------------------|
| @`PregReplace`                  | Выполняет поиск  и замену по регулярному выражению.         |
|--------------------------------|---------------------------------------------------------------|
| @`StringToLower`                | Конвертирует строку в нижний регистр.                         |
|--------------------------------|---------------------------------------------------------------|
| @`StringToUpper`                | Конвертирует строку в верхний регистр.                        |
|--------------------------------|---------------------------------------------------------------|
| @`StringTrim`                   | Убирает пробельные символы (пробелы, табуляцию и пр.) из начала и из конца строки. |
|--------------------------------|---------------------------------------------------------------|
| @`StripNewlines`                | Убирает из строки символы перехода на новую строку (ASCII-коды #13, #10). |
|--------------------------------|---------------------------------------------------------------|
| @`HtmlEntities`                 | Возвращает строку, конвертируя символы в соответствующие      |
|                                | HTML-сущности (где таковые существуют).                       |
|--------------------------------|---------------------------------------------------------------|
| @`StripTags`                    | Убирает теги (например, `<a></a>`) и комментарии (например, `<!-- -->`).|
|--------------------------------|---------------------------------------------------------------|
| @`UriNormalize`                 | Конвертирует строку URL в "нормализованную" форму и добавляет перед схемой (например, конвертирует *www.example.com* в *http://www.example.com*). |
|--------------------------------|---------------------------------------------------------------|
| @`Callback`[Laminas\Filter\Callback]                     | Позволяет использовать функцию обратного вызова в качестве фильтра. |
|--------------------------------|---------------------------------------------------------------|
| @`FilterChain`[Laminas\Filter\FilterChain]                  | Позволяет организовать несколько фильтров в цепь.             |
|--------------------------------|---------------------------------------------------------------|
| @`StaticFilter`                 | Возвращает значение, отфильтрованное указанным классом фильтра, |
|                                | без необходимости отдельного инстанцирования объекта фильтра. |
|--------------------------------|---------------------------------------------------------------|

## Инстанцирование фильтра

В Laminas Framework фильтр можно создать несколькими способами:

 * инстанцировать его вручную (с помощью оператора `new`);
 * создать его с помощью класса фабрики (передав описание в виде массива),
   этот способ чаще всего используется при добавлении в форму правил фильтрации и валидации; и
 * инстанцировать его неявно с помощью класса-обертки @`StaticFilter`.

Далее мы рассмотрим эти три способа более детально.

### Способ 1: Инстанцирование фильтра вручную

Как мы уже сказали, фильтр, в целом, можно использовать не только с формами, но и для фильтрации
произвольных данных. Чтобы это сделать, просто создайте экземпляр класса фильтра, настройте фильтр
с помощью предоставляемых им методов и вызовите метод `filter()`.

Рассмотрим, например, использование фильтра @`StringTrim`, который убирает пробелы
из начала и из конца строки.

I> Фильтр @`StringTrim` полезен для фильтрации введенных пользователем строковых данных (адреса эл. почты, имена
I> пользователей и т.д.), потому что посетители сайтов часто в них опечатываются. Например, пользователь
I> может случайно ввести пробел в конце поля электронного адреса, что сделает адрес недействительным. С
I> помощью фильтра @`StringTrim` вы легко сможете справиться с такими ошибками ввода и тем самым повысите качество обслуживания пользователей.

Методы, представленные этим фильтром, перечислены в таблице 8.2:

{title="Таблица 8.2. Public-методы фильтра StringTrim"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода *                  | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($charlistOrOptions)` | Конструктор фильтра. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Удаляет предопределенные символы из начала и из конца строки. |
|--------------------------------|---------------------------------------------------------------|
| `setCharList($charList)`       | Определяет список символов, которые нужно убрать.             |
|--------------------------------|---------------------------------------------------------------|
| `getCharList()`                | Возвращает список символов, которые нужно убрать.             |
|--------------------------------|---------------------------------------------------------------|

Как видите из таблицы выше, фильтр @`StringTrim`, вдобавок к методу `filter()`, предоставляет
метод конструктора, которому вы можете при желании передать полный список опций для инициализации фильтра,
и методы `setCharList()` и `getCharList()`, которые могут быть использованы для задания указанных опций фильтра.

I> У всех стандартных фильтров есть метод конструктора, принимающий (опционально) массив опций
I> для настройки фильтра при его инстанцировании вручную.

Ниже мы приведем два примера кода, демонстрирующие эквивалентные способы создания экземпляра @`StringTrim`
вручную, задания его опций и фильтрации значения.

**Пример 1. Передача опций методу конструктора.**

{line-numbers=on, lang=php}
~~~
<?php
// Определяем псевдоним для имени класса фильтра (опционально).
use Laminas\Filter\StringTrim;

// Создаем экземпляр фильтра, передавая опции конструктору.
$filter = new StringTrim(['charlist'=>"\r\n\t "]);

// Выполняем операцию удаления пробелов из начала и конца строки.
$filteredValue = $filter->filter(' name@example.com  ');

// Ожидаемый вывод фильтра - строка 'name@example.com'.
~~~

В этом фрагменте кода мы создали объект фильтра @`StringTrim` с помощью оператора
`new` (строка 6). Мы передаем массив опций конструктора для задания списка символов,
которые будут удалены фильтром (в этом примере мы сообщаем фильтру, что нужно удалять
символы перевода строки, символы табуляции и пробелы). Вообще, передачу массива опций
этому фильтру можно пропустить, так как у него уже есть стандартный список символов,
которые нужно убирать.

В строке 9 мы вызываем метод `filter()` и передаем ему строковое значение " name@example.com  ",
из которого хотим убрать пробелы. Ожидаемый результат этого вызова - строка "name@example.com".

**Пример 2. Без передачи опций конструктору.**

{line-numbers=on, lang=php}
~~~
<?php
// Определяем псевдоним для имени класса фильтра (опционально).
use Laminas\Filter\StringTrim;

// Создаем экземпляр фильтра.
$filter = new StringTrim();

// Указываем, какие символы надо удалять.
$filter->setCharList("\r\n\t ");

// Выполняем операцию удаления пробелов из начала и конца строки.
$filteredValue = $filter->filter(' name@example.com  ');

// Ожидаемый вывод фильтра - строка 'name@example.com'.
~~~

Во фрагменте выше мы создаем объект фильтра @`StringTrim` с помощью оператора `new`
(строка 6).

В строке 9, мы (опционально) вызываем метод `setCharList()` фильтра @`StringTrim` для задания списка
символов, которые фильтр будет удалять (в нашем примере мы сообщаем фильтру, что нужно удалять
символы перевода строки, символы табуляции и пробелы). Вызывать этот метод необязательно, так как
у фильтра уже есть стандартный список символов, которые нужно убирать.

Наконец, в строке 12 мы вызываем метод `filter()` и передаем ему строковое значение " name@example.com  ",
из которого хотим убрать пробелы. Ожидаемый результат этого вызова - строка "name@example.com".

### Способ 2: Создание фильтра с помощью StaticFilter

Альтернативный способ ручного инстанцирования фильтра - с использованием класса @`StaticFilter`.
Класс @`StaticFilter` - что-то вроде "заместителя" ("proxy"), который предназначен для автоматического
инстанцирования фильтра, настройки и выполнения. Рассмотрим, например, как создать
тот же фильтр @`StringTrim`, настроить его и вызывать его метод `filter()`:

{line-numbers=on, lang=php}
~~~
<?php
// Создание и выполнение фильтра StringTrim через "заместителя" StaticFilter.
$filteredValue = \Laminas\Filter\StaticFilter::execute(' name@example.com  ',
                        'StringTrim', ['charlist' => "\r\n\t "]);

// Ожидаемый вывод фильтра - строка 'name@example.com'.
~~~

Класс @`StaticFilter` предоставляет метод `execute()`, который принимает три
аргумента: входное значение, имя фильтра, который нужно применить, и массив
опций для выбранного фильтра.

В строке 3 мы вызываем метод `execute()`, чтобы автоматически создать фильтр @`StringTrim`,
вызвать его метод `setCharList()` и передать входное значение методу `filter()`.
Это крайне полезно, так как может быть выполнено в одну строчку кода.

### Способ 3: Создание фильтра из массива

При использовании фильтров для правил валидации формы, как правило, объект
фильтра не создают явно, как мы сделали это в предыдущем разделе; вместо этого
настройки передаются в виде массива классу фабрики, который автоматически создает
фильтр. Мы уже сталкивались с подобным способом
при добавлении правил валидации для формы обратной связи в главе
[Сбор пользовательских данных с помощью форм](#forms).

В качестве примера покажем, как создать все тот же фильтр @`StringTrim` с
помощью фабрики:

{line-numbers=on, lang=php}
~~~
<?php
// Предполагается, что вы вызываете следующий код внутри метода
// addInputFilter() модели формы.

$inputFilter->add([
  // ...
  'filters'  => [
    [
      'name' => 'StringTrim',
      'options' => [
        'charlist' => "\r\n\t "
      ]
    ],
  ],
  // ...
];
~~~

В фрагменте кода выше мы вызываем метод `add()`, предоставляемый классом-контейнером @`InputFilter`[Laminas\InputFilter\InputFilter] (строка 5).
Метод `add()` принимает массив, который имеет ключ `filters`. Как правило, фильтры регистрируются
под этим ключом (строка 7). Фильтры, зарегистрированные под этим ключом, вставляются в цепь фильтров
в том же порядке, что и в списке.

Конфигурация фильтра обычно состоит из имени - `name`  (строка 9) и опций - `options` (строка 10). Имя -
это полностью определенное имя класса фильтра (например, @`Laminas\Filter\StringTrim`), либо его
псевдоним (`StringTrim`). `options` - это массив, состоящий из опций конкретного фильтра. Когда
класс фабрики инстанцирует фильтр, он передает список опций методу конструктора фильтра, а конструктор
при необходимости инициализирует фильтр.

## О менеджере плагинов фильтров

В предыдущем примере вы видели, что при инстанцировании фильтра из массива можно использовать либо полностью
определенное имя класса фильтра, либо его псевдоним. Псевдонимы для стандартных фильтров определяются классом
@`FilterPluginManager`[Laminas\Filter\FilterPluginManager].

I> Класс @`FilterPluginManager`[Laminas\Filter\FilterPluginManager] определяет псевдонимы для стандартных фильтров.

Псевдоним стандартного фильтра, как правило, такой же, как и имя класса. Например, у
класса @`Laminas\Filter\StringTrim` псевдоним - `StringTrim`.

Менеджер плагинов фильтров внутренне используется классом-контейнером @`InputFilter`[Laminas\InputFilter\InputFilter] для
инстанцирования стандартных фильтров.

## Поведение фильтра в случае некорректных входных данных

Разные фильтры ведут себя по-разному, когда вы передаете им входные данные, которые фильтр не может
корректно обработать.

Некоторые фильтры (такие как @`ToInt`) будут обрабатывать только скалярные данные. Если вы передадите
такому фильтру массив, он вернет вам массив как есть.

Некоторые фильтры могут работать только с данными в определенном формате (например, только с датами). Если
фильтрация входных данных невозможна (например, при передаче фильтру неверных данных, которые он не в состоянии
обработать), метод `filter()` может выбросить исключение @`Laminas\Filter\Exception\RuntimeException`.
Такое поведение можно наблюдать в фильтре @`DateTimeFormatter`.

Некоторые фильтры (например, @`ToInt` или @`StringToLower`) могут выдать PHP-предупреждение, если
значение предоставлено в некорректном формате и не может быть отфильтровано.

T> Рекомендуется внимательно читать документацию фильтра, чтобы знать, чего ожидать
T> от фильтра, который вы планируете использовать в своей форме.

## Примеры использования фильтров

Далее мы рассмотрим примеры использования самых важных стандартных фильтров. Мы
опишем методы (и опции) фильтра и приведем фрагменты кода, показывающие, как
инстанцировать фильтр и применить его к входным данным. Если вам нужно использовать
фильтр, не рассматриваемый в этом разделе, обратитесь к разделу *Стандартные фильтры*
*Справочного руководства Laminas Framework*.

### Фильтры, приводящие входные данные к определенному типу

В этом разделе мы расскажем о нескольких фильтрах из группы фильтров, связанных
с приведением входных данных к определенному типу, и приведем примеры их использования.

#### Фильтр ToInt

Фильтр @`ToInt` - очень простой фильтр, предназначенный для приведения произвольных
скалярных данных к типу integer. Этот фильтр может быть полезен при добавлении правил
валидации для полей формы, которые должны содержать числовые значения типа integer (например,
выпадающий список или текстовое поле, содержащее количество чего-либо).

Класс @`ToInt` имеет единственный метод `filter()`.

I> Фильтр @`ToInt` не будет приводить нескалярные значения. Если вы передадите ему массив,
I> он вернет его как есть.

Ниже показан пример кода, демонстрирующий использование фильтра @`ToInt`.

{line-numbers=on, lang=php}
~~~
<?php
// Создаем фильтр ToInt.
$filter = new \Laminas\Filter\ToInt();

// Фильтруем значение, приводя его к типу integer.
$filteredValue = $filter->filter('10'); // Возвращает (int) 10.
$filteredValue2 = $filter->filter(['10', '20']); // Возвращает массив как есть.
~~~

Во фрагменте выше мы передаем фильтру строку "10" (строка 6). Ожидаемое возвращаемое
значение - 10 (типа integer).

В строке 7 мы передаем фильтру массив. Так как фильтр @`ToInt` работает только со скалярными значениями,
он возвращает массив как есть (без изменений) и выдает PHP-предупреждение.

#### Фильтр Boolean

Класс @`Boolean`[Laminas\Filter\Boolean] - это фильтр, предназначенный для приведения произвольных данных к булевому значению
(`true` или `false`). Этот фильтр может использоваться для фильтрации полей формы флажка.

Его public-методы перечислены в таблице 8.3.

{title="Таблица 8.3. Public-методы фильтра Boolean"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Возвращает булевое представление `$value`.                    |
|--------------------------------|---------------------------------------------------------------|
| `setCasting($flag)`            | Устанавливает флаг приведения.                                |
|--------------------------------|---------------------------------------------------------------|
| `getCasting()`                 | Возвращает флаг приведения.                                   |
|--------------------------------|---------------------------------------------------------------|
| `setType($type)`               | Задает типы, которые нужно приводить.                         |
|--------------------------------|---------------------------------------------------------------|
| `getType()`                    | Возвращает типы.                                              |
|--------------------------------|---------------------------------------------------------------|
| `setTranslations($translations)`| Задает переводы.                                             |
|--------------------------------|---------------------------------------------------------------|
| `getTranslations()`            | Возвращает переводы.                                          |
|--------------------------------|---------------------------------------------------------------|

Этот фильтр предоставляет несколько методов, позволяющих задать опции фильтрации (`setCasting()`, `setType()`,
и `setTranslations()`).

Метод `setCasting()` позволяет выбрать один из двух режимов работы фильтра. Если флаг установлен
в значение true, фильтр будет вести себя как оператор приведения PHP (к типу `boolean`). Иначе
(если флаг установлен в значение `false`), он будет приводить только типы, определенные методом
`setType()`, а другие значения возвращать как есть.

Метод фильтра `setType()` позволяет определить, какие типы нужно приводить. Этот метод принимает
один аргумент `$type`, который может быть либо комбинацией ИЛИ констант с префиксом `TYPE_`, либо
массивом, содержащим буквенные эквиваленты констант. Константы, принимаемые методом, и их
буквенные эквиваленты перечислены в таблице 8.4:

{title="Таблица 8.4. Константы типов"}
|----------------------|--------------------|----------------------|----------------------------------------|
| *Константа*          | *Числовое значение*| *Буквенный эквивалент*| *Описание*                            |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_BOOLEAN`       | 1                  | "boolean"            | Возвращает булевое значение как есть.  |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_INTEGER`       | 2                  | "integer"            | Конвертирует integer-значение 0 в `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_FLOAT`         | 4                  | "float"              | Конвертирует float-значение 0.0 в `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_STRING`        | 8                  | "string"             | Конвертирует пустую строку '' в `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_ZERO_STRING`   | 16                 | "zero"               | Конвертирует строку, содержащую один символ нуля ('0') в `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_EMPTY_ARRAY`   | 32                 | "array"              | Конвертирует пустой массив в `false`.  |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_NULL`          | 64                 | "null"               | Конвертирует значение `null` в `false`.|
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_PHP`           | 127                | "php"                | Конвертирует значения согласно PHP при приведении к типу boolean. (Это поведение по умолчанию.) |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_FALSE_STRING`  | 128                | "false"              | Конвертирует строку, содержащую слово "false" в булевое `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_LOCALIZED`     | 256                | "localized"          | Конвертирует локализованную строку, которая содержит определенное слово, в boolean. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_ALL`           | 511                | "all"                | Конвертирует все вышеперечисленные типы в boolean. |
|----------------------|--------------------|----------------------|----------------------------------------|

Следующий пример кода показывает два эквивалентных способа вызова метода `setType()`:

~~~php
<?php
use Laminas\Filter\Boolean;

// Вызываем метод setType() и передаем ему комбинацию констант.
$filter->setType(Boolean::TYPE_BOOLEAN|
                 Boolean::TYPE_INTEGER|
                 Boolean::TYPE_STRING);

// Вызываем метод setType() и передаем ему массив буквенных эквивалентов.
$filter->setType(['boolean', 'integer', 'string']);
~~~

Метод `setTranslations()` позволяет определить локализованные эквиваленты булевых значений
`true` и `false`. Этот принимает один параметр, который должен быть массивом в виде пар *ключ=>значение*,
где *ключ* - локализованная строка, а *значение* - его булевое представление. Следующий пример кода
показывает, как использовать метод `setTranlsations()`:

~~~php
<?php
$filter->setTranslations([
  'yes' => true,    // Английское 'да'
  'no'  => false,   // Английское 'нет'
  'ja'  => true,    // Немецкое 'да'
  'nicht' => false, // Немецкое 'нет'
  'да'  => true,    // Русское 'да'
  'нет' => false    // Русское 'нет'
  ]);
~~~

Ниже приведен фрагмент кода, демонстрирующий использование фильтра @`Boolean`[Laminas\Filter\Boolean].

~~~php
<?php
// Создаем фильтр Boolean.
$filter = new \Laminas\Filter\Boolean();

// Настраиваем фильтр (опционально).
$filter->setCasting(true);
$filter->setType(\Laminas\Filter\Boolean::TYPE_ALL);
$filter->setTranslations(['yes'=>true, 'no'=>false]);

// Фильтруем значение, приводя его к типу boolean.
$filteredValue = $filter->filter('false'); // Возвращает булевое false.
$filteredValue2 = $filter->filter('1'); // Возвращает булевое true.
$filteredValue3 = $filter->filter('false'); // Возвращает булевое false.
$filteredValue4 = $filter->filter('yes'); // Возвращает булевое true.
~~~

#### Фильтр ToNull

Фильтр @`ToNull` предназначен для приведения произвольных данных к значению `null`, если они отвечают
определенным критериям. Это может быть полезно, когда вы работаете с базой данных и хотите использовать
для значения тип `null` вместо любого другого типа. Если значение нельзя трактовать как NULL, фильтр
вернет значение как есть.

Public-методы фильтра @`ToNull` перечислены в таблице 8.5.

{title="Таблица 8.5. Public-методы фильтра ToNull"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Приводит `$value` к `null`, если это возможно; иначе возвращает значение как есть. |
|--------------------------------|---------------------------------------------------------------|
| `setType($type)`               | Определяет, какие типы нужно приводить.                       |
|--------------------------------|---------------------------------------------------------------|
| `getType()`                    | Возвращает определенные типы.                                 |
|--------------------------------|---------------------------------------------------------------|

По умолчанию фильтр @`ToNull` ведет себя как PHP-функция `empty()`: если эта функция возвращает
булевое `true` при передаче ей входных данных, то фильтр также вернет значение `null` при этих
данных.

Метод `setType()` может быть использован для задания типа, который фильтр будет приводить к `null`.
Этот метод принимает один параметр, который может быть либо комбинацией ИЛИ констант с префиксом `TYPE_`,
перечисленных в таблице 8.6, либо массивом их буквенных эквивалентов.

{title="Таблица 8.6. Константы типов"}
|---------------------|-----------------|----------------------|----------------------------------------|
| *Константа*         | *Числовое значение* | *Буквенный эквивалент* | *Описание*                       |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_BOOLEAN`      | 1               | "boolean"            | Конвертирует булевое значение `false` в `null`. |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_INTEGER`      | 2               | "integer"            | Конвертирует integer-значение 0 в `null`. |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_EMPTY_ARRAY`  | 4               | "array"              | Конвертирует пустой массив в `null`.   |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_STRING`       | 8               | "string"             | Конвертирует пустую строку '' в `null`.|
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_ZERO_STRING`  | 16              | "zero"               | Конвертирует строку, содержащую один символ нуля  ('0') в `null`. |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_FLOAT`        | 32              | "float"              | Конвертирует float-значение 0.0 в `null`. |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_ALL`          | 63              | "all"                | Конвертирует все вышеперечисленные типы в `null`. Это поведение по умолчанию. |
|---------------------|-----------------|----------------------|----------------------------------------|

Следующий пример кода демонстрирует два способа вызова метода `setType()`:

~~~php
<?php
use Laminas\Filter\ToNull;

// Вызываем метод setType() и передаем ему комбинацию констант.
$filter->setType(ToNull::TYPE_ZERO_STRING|Null::TYPE_STRING);

// Вызываем метод setType() и передаем ему массив буквенных эквивалентов.
$filter->setType(['zero', 'string']);
~~~

Ниже приведен фрагмент кода, показывающий, как использовать фильтр @`ToNull`:

~~~php
<?php
// Создаем фильтр ToNull.
$filter = new \Laminas\Filter\ToNull();

// Настраиваем фильтр (опционально).
$filter->setType(\Laminas\Filter\ToNull::TYPE_ALL);

$filteredValue = $filter->filter('0'); // Возвращает null.
$filteredValue2 = $filter->filter('1'); // Возвращает строку string '1'.
$filteredValue3 = $filter->filter(false); // Возвращает null.
~~~

#### Фильтр DateTimeFormatter

Фильтр @`DateTimeFormatter` принимает дату в произвольном формате и конвертирует
в желаемый формат.

I> Этот фильтр может принимать строку (например, '2014-03-22 15:36'), метку времени типа integer
I> (такую, как возвращает PHP-функция `time()`) или экземпляр PHP-класса `DateTime`.
I> Фильтр @`DateTimeFormatter` может выбрасывать исключение @`Laminas\Filter\Exception\InvalidArgumentException`,
I> если вы передадите ему дату в некорректном формате.

Public-методы этого фильтра перечислены в таблице 8.7.

{title="Таблица 8.7. Public-методы фильтра DateTimeFormatter"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Преобразовывает дату в желаемый формат.                       |
|--------------------------------|---------------------------------------------------------------|
| `setFormat($format)`           | Задает формат даты.                                           |
|--------------------------------|---------------------------------------------------------------|

Во фрагменте кода ниже мы покажем, как создать фильтр, передать ему дату в виде строки и
конвертировать ее в желаемый формат.

~~~php
<?php
// Создаем фильтр DateTimeFormatter.
$filter = new \Laminas\Filter\DateTimeFormatter();

// Задаем формат фильтра (опционально).
$filter->setFormat('F j, Y g:i A');

// Преобразовываем дату в указанный формат.
$filteredValue = $filter->filter('2014-03-22 15:36');

// Ожидаемый результат - 'March 22, 2014 3:36 PM'.
~~~

I> Фильтр @`DateTimeFormatter` внутренне использует класс `DateTime` из стандартной библиотеки
I> PHP для конвертации и форматирования дат. Доступные форматы дат вы можете посмотреть в
I> документации класса `DateTime`.

### Фильтры, выполняющие манипуляции с путем файла

В этом разделе мы рассмотрим примеры использования фильтров из группы фильтров, связанных
с обработкой путей файлов.

#### Фильтр BaseName

Класс фильтра @`BaseName` - это лишь обертка  PHP-функции `basename()`.
Он принимает строку, содержащую путь к файлу или каталогу, и возвращает
последний компонент имени.

Ниже показан пример использования фильтра @`BaseName`.

~~~php
<?php
// Создаем фильтр BaseName.
$filter = new \Laminas\Filter\BaseName();

// Фильтруем путь файла и возвращаем его последнюю часть.
$filteredValue = $filter->filter('/var/log/httpd/error.log');

// Ожидаемый вывод фильтра - 'error.log'.
~~~

I> Фильтр @`BaseName` не будет обрабатывать нескалярное значение. Если вы передадите
I> ему массив, он вернет его как есть и выдаст PHP-предупреждение.

#### Фильтр Dir

Класс фильтра @`BaseName` - это лишь обертка  PHP-функции `dirname()`.
Он принимает строку, содержащую путь к файлу или каталогу, и возвращает
путь родительского каталога.

I> Фильтр @`Dir` не будет обрабатывать нескалярное значение. Если вы передадите
I> ему массив, он вернет его как есть.

Фрагмент кода ниже демонстрирует пример использования фильтра @`Dir`.

~~~php
<?php
// Создаем фильтр Dir.
$filter = new \Laminas\Filter\Dir();

// Фильтруем путь файла и возвращаем имя его каталога.
$filteredValue = $filter->filter('/var/log/httpd/error.log');

// Ожидаемый вывод фильтра - '/var/log/httpd'.
~~~

#### Фильтр RealPath

Фильтр @`RealPath` принимает абсолютный или относительный путь к файлу в виде строкового аргумента.
Он раскрывает все символические ссылки, переходы типа '/./', '/../' и лишние символы '/' в пути,
возвращая канонизированный абсолютный путь к файлу.

I> Фильтр @`RealPath` - это обертка PHP-функции `realpath()`.

Public-методы фильтра перечислены в таблице 8.8.

{title="Таблица 8.8. Public-методы фильтра RealPath"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Вовращает канонизированный абсолютный путь к файлу.           |
|--------------------------------|---------------------------------------------------------------|
| `setExists($flag)`             | Указывает, должен ли существовать путь для успешной работы фильтра.  |
|                                | Значение `true` означает, что путь должен существовать; значение `false` |
|                                | означает, что можно передать несуществующий путь.             |
|--------------------------------|---------------------------------------------------------------|
| `getExists()`                  | Возвращает `true`, если фильтруемый путь должен существовать. |
|--------------------------------|---------------------------------------------------------------|

Фильтр @`RealPath` возвращает булевое `false` при неудаче, например, если файла не существует.
Если несуществующий путь разрешен, вы можете вызвать метод `setExists()` с параметром `false`.

Фрагмент кода ниже демонстрирует пример использования фильтра @`RealPath`.

~~~php
<?php
// Создаем фильтр RealPath.
$filter = new \Laminas\Filter\RealPath();

// Фильтруем путь к файлу (предполагается, что текущий
// рабочий каталог - /var/log/httpd, и что он содержит
// файл error.log).
$filteredValue = $filter->filter('./error.log');

// Ожидаемый вывод фильтра - '/var/log/httpd/error.log'.
~~~

I> Фильтр @`RealPath` не будет обрабатывать нескалярное значение. Если вы передадите
I> ему массив, он вернет его как есть.

### Фильтры, осуществляющие сжатие и шифрование входных данных

В этом разделе мы рассмотрим несколько фильтров из группы фильтров, связанных
со сжатием и шифрованием входных данных. Эти фильтры не особо подходят для
фильтрации данных форм, но могут с большим успехом использоваться вне форм.

#### Фильтр Compress

Фильтр @`Compress` предназначен для сжатия входных данных с помощью некоторого алгоритма сжатия.
Например, этот фильтр можно использовать, чтобы сжать данные и сохранить их в виде архива.

Public-методы фильтра перечислены в таблице 8.9.

{title="Таблица 8.9. Public-методы фильтра Compress"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Производит сжатие данных, используя указанный алгоритм.       |
|--------------------------------|---------------------------------------------------------------|
| `getAdapter()`                 | Возвращает текущий адаптер, инстанцируя его, если необходимо. |
|--------------------------------|---------------------------------------------------------------|
| `getAdapterName()`             | Извлекает имя адаптера.                                       |
|--------------------------------|---------------------------------------------------------------|
| `setAdapter($adapter)`         | Задает адаптер сжатия.                                        |
|--------------------------------|---------------------------------------------------------------|
| `getAdapterOptions()`          | Извлекает опции адаптера.                                     |
|--------------------------------|---------------------------------------------------------------|
| `setAdapterOptions($options)`  | Задает опции адаптера.                                        |
|--------------------------------|---------------------------------------------------------------|
| `getOptions($option)`          | Получает отдельную или все опции используемого адаптера.      |
|--------------------------------|---------------------------------------------------------------|

Сам фильтр @`Compress` не может сжимать данные. Вместо этого он использует так называемый
класс *адаптера*. Класс адаптера должен реализовывать интерфейс @`CompressionAlgorithmInterface`.
Вы добавляете адаптер к фильтру @`Compress`, и адаптер реализует определенный алгоритм сжатия.

Существует несколько стандартных классов адаптеров (см. рисунок 8.2 и таблицу 8.10). Эти классы
"живут" в пространстве имен @`Laminas\Filter\Compress`.

{title="Таблица 8.10. Адаптеры сжатия"}
|--------------------------------|---------------------------------------------------------------|
| *Class name*                   | *Description*                                                 |
|--------------------------------|---------------------------------------------------------------|
| @`Bz2`                          | [Bzip2](http://www.bzip.org/) - алгоритм сжатия Барроуза-Уилера. |
|--------------------------------|---------------------------------------------------------------|
| @`Gz`                           | Алгоритм сжатия [Gzip](http://www.gzip.org/) основан на алгоритме Deflate, являющимся комбинацией алгоритма LZ77 и кодирования Хаффмана. |
|--------------------------------|---------------------------------------------------------------|
| @`Zip`                          | ZIP - алгоритм сжатия, широко используемый в операционной системе Windows. |
|--------------------------------|---------------------------------------------------------------|
| @`Tar`                          | Формат файла [Tarball](http://www.gnu.org/software/tar/tar.html) обычно используется, чтобы собрать много файлов в один большой для архивирования, сохраняя информацию файловой системы: права пользователя/группы, даты и структуры каталогов. Широко используется в операционной системе Linux.
|--------------------------------|---------------------------------------------------------------|
| @`Lzf`                          | LZF - очень быстрый алгоритм сжатия, идеальный для экономии пространства без большого ущерба для скорости. |
|--------------------------------|---------------------------------------------------------------|
| @`Snappy`                       | [Snappy](https://code.google.com/p/snappy/) - основанная на идея LZ77 библиотека для быстрого сжатия и распаковки данных, разработанная Google. |
|--------------------------------|---------------------------------------------------------------|
| @`Rar`                          | RAR - формат архива, поддерживающий сжатие данных, устранение ошибок и разделение одного файла на несколько. |
|--------------------------------|---------------------------------------------------------------|

![Рисунок 8.2. Наследование адаптеров алгоритмов сжатия](../en/images/filters/compression_algorithm_inheritance.png)

Фрагмент кода ниже демонстрирует пример использования фильтра @`Compress`.

{line-numbers=on, lang=php}
~~~
<?php
// Создаем фильтр Compress.
$filter = new \Laminas\Filter\Compress();

// Настраиваем адаптер.
$filter->setAdapter('Zip');
$filter->setAdapterOptions([
        'archive' => 'example.zip',
    ]);

// Сжимаем входные данные (предполагается, что в текущем рабочем каталоге
// находится файл testfile.txt ).
$filter->filter('testfile.txt');
~~~

В примере выше мы создаем экземпляр фильтра @`Compress (строка 3), задаем его адаптер (строка 6),
задаем опции адаптера (строка 7) и затем сжимаем входной файл (строка 13). Ожидаемый результат,
файл архива *example.zip*, будет создан в текущем каталоге. Архив будет содержать файл *testfile.txt*.

I> Фильтр @`Decompress` является "зеркальным отражением" фильтра @`Compress` и используется
I> аналогично. По этой причине мы не будем рассматривать фильтр @`Decompress` в этом разделе.

#### Фильтр Encrypt

Задача фильтра @`Encrypt`[Laminas\Filter\Encrypt] - шифрование входных данных с помощью указанного алгоритма.
Public-методы фильтра перечислены в таблице 8.11.

{title="Таблица 8.11. Public-методы фильтра Encrypt"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Производит шифрование данных, используя указанный алгоритм.   |
|--------------------------------|---------------------------------------------------------------|
| `getAdapter()`                 | Возвращает текущий адаптер, инстанцируя его, если необходимо. |
|--------------------------------|---------------------------------------------------------------|
| `setAdapter($adapter)`         | Задает адаптер сжатия.                                        |
|--------------------------------|---------------------------------------------------------------|

Фильтр @`Encrypt`[Laminas\Filter\Encrypt] использует классы *адаптеров* для непосредственной шифровки данных. Вы добавляете
адаптер к фильтру `Encrypt`[Laminas\Filter\Encrypt] с помощью метода `setAdapter()`, и адаптер производит определенное шифрование.
Класс адаптера должен реализовывать интерфейс @`EncryptionAlgorithmInterface`.

Существует несколько стандартных классов адаптеров (см. рисунок 8.3). Эти классы
"живут" в пространстве имен @`Laminas\Filter\Encrypt`[Laminas\Filter].

 * @`BlockCipher`[Laminas\Filter\Encrypt\BlockCipher] -- реализует симметричный блочный алгоритм шифрования.
 * @`Openssl`[Laminas\Filter\Encrypt\Openssl] -- использует алгоритм шифрования из библиотеки OpenSSL.

![Рисунок 8.3. Наследование адаптеров алгоритмов шифрования](../en/images/filters/encryption_algorithm_inheritance.png)

Фрагмент кода ниже демонстрирует пример использования фильтра @`Encrypt`[Laminas\Filter\Encrypt].

{line-numbers=on, lang=php}
~~~
<?php
// Создаем фильтр Encrypt.
$filter = new \Laminas\Filter\Encrypt();

// Задаем адаптер шифрования.
$filter->setAdapter('BlockCipher');

// Зашифровываем входные данные.
$filteredValue = $filter->filter('some data to encrypt');
~~~

Ожидаемые результат - строка, зашифрованная блочным шифром.

I> Фильтр @`Decrypt`[Laminas\Filter\Decrypt] является "зеркальным отражением" фильтра @`Encrypt`[Laminas\Filter\Encrypt] и используется
I> аналогично. По этой причине мы не будем рассматривать фильтр @`Decrypt`[Laminas\Filter\Decrypt] в этом разделе.

### Фильтры, управляющие строковыми данными

В этом разделе мы рассмотрим примеры использования фильтров из группы фильтров,
связанных с изменением строковых данных.

#### Фильтр StringToLower

Класс фильтра @`StringToLower` предназначен для преобразования входных строковых данных в символы
нижнего регистра. Public-методы фильтра представлены ниже в таблице 8.12.

{title="Таблица 8.12. Public-методы фильтра StringToLower"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Конвертирует строку в нижний регистр.                         |
|--------------------------------|---------------------------------------------------------------|
| `setEncoding($encoding)`       | Задает кодировку входных данных для заданной строки.          |
|--------------------------------|---------------------------------------------------------------|
| `getEncoding()`                | Возвращает кодировку.                                         |
|--------------------------------|---------------------------------------------------------------|

По умолчанию, фильтр работает как PHP-функция `strtolower()`. Принимая строковое значение, он возвращает
строку, в которой все буквенные символы переведены в нижний регистр. Принадлежность символа к "буквенным"
определяется локалью системы. Это значит, что, например, в стандартной локали "C" такие символы, как «а-умлаут» (Ä)
не будут конвертированы.

Вызов метода `setEncoding()` на фильтре и передача ему кодировки принуждает фильтр вести себя
как PHP-функция `mb_strtolower()`. В отличие от `strtolower()` то, что символ является буквой,
определяется свойствами символа Юникода. Поэтому поведение этой функции не зависит от настроек
локали, и она может конвертировать любой символ, определяемый в Юникоде как "буква", например, «а-умлаут» (Ä).

I> Если представленное значение нескалярное, оно останется неотфильтрованным,
I> и будет выдано предупреждение `E_USER_WARNING`, указывающее на то, что значение не может быть отфильтровано.

Фрагмент кода ниже показывает, как использовать фильтр @`Encrypt`[Laminas\Filter\Encrypt]:

~~~php
<?php
// Создаем фильтр StringToLower.
$filter = new \Laminas\Filter\StringToLower();

// Задаем кодировку для фильтра (опционально).
$filter->setEncoding('UTF-8');

// Фильтруем строку.
$filteredValue = $filter->filter('How to Start a Business in 10 Days');

// Ожидаемый вывод фильтра - 'how to start a business in 10 days'.
~~~

I> Фильтр @`StringToUpper` (перед строки в верхний регистр) является "зеркальным отражением" фильтра @`StringToLower` и
I> используется аналогично. По этой причине мы не будем рассматривать фильтр @`StringToUpper` в этом разделе.

#### Фильтр PregReplace

Фильтр @`PregReplace` может быть использован для поиска и замены строковых данных по регулярному выражению.
Этот фильтр - обертка PHP-функции `preg_replace()`. Public-методы этого фильтра представлены ниже в таблице 8.13.

{title="Таблица 8.13. Public-методы фильтра PregReplace"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Выполняет поиск и замену по регулярному выражению.            |
|--------------------------------|---------------------------------------------------------------|
| `setPattern($pattern)`         | Задает искомый шаблон. Это может быть либо строка, либо массив строк. |
|--------------------------------|---------------------------------------------------------------|
| `getPattern()`                 | Возвращает шаблон.                                             |
|--------------------------------|---------------------------------------------------------------|
| `setReplacement($replacement)` | Задает строку или массив строк, используемые в качестве замены. |
|--------------------------------|---------------------------------------------------------------|
| `getReplacement()`             | Получает установленное в данный момент значение замены.       |
|--------------------------------|---------------------------------------------------------------|

Фрагмент кода ниже показывает, как использовать фильтр @`PregReplace`:

~~~php
<?php
// Создаем фильтр PregReplace.
$filter = new \Laminas\Filter\PregReplace();

// Настраиваем фильтр.
$filter->setPattern("/\s\s+/");
$filter->setReplacement(' ');

// Фильтруем строку.
$filteredValue = $filter->filter('An example    with    multiple     spaces.');

// Ожидаемый вывод фильтра - 'An example with multiple spaces.'
~~~

#### Фильтр StripTags

Фильтр @`StripTags` удаляет все теги (например, `<!-- -->`, `<p>`, `<h1>` или `<?php ?>`) из входной строки.
Он также позволяет явно определить теги, которые не должны быть удалены. Кроме этого, фильтр предоставляет
возможность указать, какие атрибуты всех и/или только определенных тегов разрешены.

Public-методы фильтра @`StripTags` перечислены в таблице 8.14.

{title="Таблица 8.14. Public-методы фильтра StripTags"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Возвращает значение, из которого удалены теги.                |
|--------------------------------|---------------------------------------------------------------|
| `getAttributesAllowed()`       | Возвращает список разрешенных атрибутов тегов.                |
|--------------------------------|---------------------------------------------------------------|
| `setAttributesAllowed($attributesAllowed)` | Задает список разрешенных атрибутов тегов.        |
|--------------------------------|---------------------------------------------------------------|
| `getTagsAllowed()`             | Возвращает список разрешенных тегов.                          |
|--------------------------------|---------------------------------------------------------------|
| `setTagsAllowed($tagsAllowed)` | Задает список разрешенных тегов.                               |
|--------------------------------|---------------------------------------------------------------|

Фрагмент кода ниже показывает, как использовать фильтр @`StripTags`:

~~~php
<?php
// Создаем фильтр StripTags.
$filter = new \Laminas\Filter\StripTags();

// Настраиваем фильтр.
$filter->setTagsAllowed(['p']);

// Фильтруем строку.
$filteredValue = $filter->filter(
  '<p>Please click the following <a href="example.com">link</a>.</p>');

// Ожидаемый вывод фильтра -
// '<p>Please click the following link.</p>;'
~~~

I> `StripTags` не будет обрабатывать нескалярное значение. Если передать фильтру такое значение,
I> оно останется неотфильтрованным.

#### Фильтр StripNewlines

StripNewlines` - весьма простой фильтр, который возвращает входную строку без
символов перевода строки ("\r", "\n").

Фрагмент кода ниже показывает, как использовать фильтр @`StripNewlines`:

~~~php
<?php
// Создаем фильтр StripNewlines.
$filter = new \Laminas\Filter\StripNewlines();

// Фильтруем строку.
$filteredValue = $filter->filter("A multi line\r\n string");

// Ожидаемый вывод фильтра - 'A multi line string'.
~~~

I> @`StripNewlines` не будет обрабатывать нескалярное значение. Если передать фильтру такое значение,
I> оно останется неотфильтрованным.

#### Фильтр UriNormalize

Фильтр @`UriNormalize` может использоваться для нормализации URL-строки и (опционально) применения к
ней схемы. Public-методы этого фильтра приведены ниже в таблице 8.15.

{title="Таблица 8.15. Public-методы фильтра UriNormalize"}
|------------------------------------|---------------------------------------------------------------|
| *Имя метода*                       | *Описание*                                                    |
|------------------------------------|---------------------------------------------------------------|
| `filter($value)`                   | Фильтрует URL, нормализуя его и применяя схему по умолчанию (если она задана). |
|------------------------------------|---------------------------------------------------------------|
| `setDefaultScheme($defaultScheme)` | Задает схему по умолчанию для использования при разборе URI, не имеющим схем.  |
|------------------------------------|---------------------------------------------------------------|
| `setEnforcedScheme($enforcedScheme)` | Задает схему для применения к URI, не имеющим схем.         |
|------------------------------------|---------------------------------------------------------------|

Процедура нормализации URL, как правило, состоит из следующих шагов:

1. Строка URL разбивается на части: схему, хост, номер порта, путь и запрос.
   Если у заданного URL нет схемы, используется схема по умолчанию.
2. Части схемы и хоста переводятся в нижний регистр.
3. Номер порта сверяется со списком разрешенных номеров, и, если он не принадлежит этому списку, номер порта убирается.
4. Путь URL фильтруется: удаляются лишние сегменты точек, декодируются любые
   URL-закодированные символы, а также URL-кодируется все, что должно быть закодировано.
5. Часть запроса очищается: URL-декодируется все, что не должно быть закодированным и URL-кодируется
   все остальное.

Правила нормализации URL могут отличаться для разных протоколов (схем). Если URL не содержит часть схемы, по умолчанию
присваивается схема `http`. Вы можете использовать метод `setDefaultScheme()` фильтра UriNormalize`, чтобы установить
схему по умолчанию для нормализации URL. Он принимает любую из следующих схем: `http`, `https`, `file`, `mailto`,
`urn` и `tag`.

Кроме того, другой метод фильтра @`UriNormalize, `setEnforcedScheme()`, позволяет переопределить
схему по умолчанию так называемой "принудительной" схемой, если заданный URL не имеет части схемы.

Фрагмент кода ниже показывает, как использовать фильтр @`UriNormalize`:

~~~php
<?php
// Создаем фильтр UriNormalize.
$filter = new \Laminas\Filter\UriNormalize();

// Настраиваем фильтр.
$filter->setDefaultScheme('http');
$filter->setEnforcedScheme('https');

// Фильтруем URL-строку.
$filteredValue = $filter->filter('www.example.com');

// Ожидаемый вывод фильтра - 'https://www.example.com/'.
~~~

### Организация фильтров в цепь

Фильтры могут быть организованы в последовательность. Это можно сделать с помощью класса @`FilterChain`[Laminas\Filter\FilterChain].
При запуске подобного составного фильтра, значение, отфильтрованное первым фильтром передается второму
в качестве входных данных, затем значение, отфильтрованное вторым фильтром передается третьему и так далее.

I> Класс `FilterChain`[Laminas\Filter\FilterChain] внутренне используется классом-контейнером @`InputFilter`[Laminas\InputFilter\InputFilter] для хранения
I> последовательности фильтров, присоединенных к полю модели формы.

Public-методы, предоставляемые классом @`FilterChain`[Laminas\Filter\FilterChain], представлены в таблице 8.16:

{title="Таблица 8.16. Public-методы фильтра FilterChain"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Возвращает значение, отфильтрованное каждым фильтром цепи. Фильтры запускаются в том же порядке, в котором были добавлены в цепь (FIFO - «первым пришёл — первым ушёл»). |
|--------------------------------|---------------------------------------------------------------|
| `setOptions($options)`         | Задает опции.                                                 |
|--------------------------------|---------------------------------------------------------------|
| `attach($callback, $priority)` | Добавляет к цепи существующий экземпляр фильтра (или функцию обратного вызова). |
|------------------------------------|---------------------------------------------------------------|
| `attachByName($name, $options, $priority)` | Инстанцирует фильтр по имени класса или псевдониму и вставляет его в цепь. |
|--------------------------------|---------------------------------------------------------------|
| `merge($filterChain)`          | Объединяет одну цепочку фильтров с другой.                       |
|--------------------------------|---------------------------------------------------------------|
| `getFilters()`                 | Возвращает все присоединенные фильтры                         |
|--------------------------------|---------------------------------------------------------------|
| `count()`                      | Возвращает количество присоединенных фильтров.                 |
|--------------------------------|---------------------------------------------------------------|

Пример цепочки фильтров показан на рисунке 8.4. Она состоит из фильтра @`StringTrim`, за которым идет фильтр
@`StripTags`, за которым в свою очередь следует фильтр @`StripNewlines`.

![Рисунок 8.4. Цепь фильтров](../en/images/filters/filter_chain.png)

Для создания цепочки как на рисунке 8.4 мы используем следующий код:

{line-numbers=on, lang=php}
~~~
<?php
use Laminas\Filter\FilterChain;

// Инстанцируем цепь фильтров.
$filter = new FilterChain();

// Вставляем фильтры в цепочку.
$filter->setOptions([
    'filters'=>[
        [
            'name'=>'StringTrim',
            'options'=>['charlist'=>"\r\n\t "],
            'priority'=>FilterChain::DEFAULT_PRIORITY
        ],
        [
            'name'=>'StripTags',
            'options'=>['tagsallowed'=>['p']],
            'priority'=>FilterChain::DEFAULT_PRIORITY
        ],
        [
            'name'=>'StripNewlines',
            'priority'=>FilterChain::DEFAULT_PRIORITY
        ]
    ]
]);

// Выполняем все фильтры в цепи.
$filteredValue = $filter->filter("  name@example.com<html>\n ");

// Ожидаемый вывод - 'name@example.com'.
~~~

В этом фрагменте первым делом мы инстанцируем фильтр @`FilterChain`[Laminas\Filter\FilterChain] с помощью оператора `new` (строка 5).
В строке 8 мы задаем конструкцию цепочки фильтров методом `setOptions()`.

Этот метод принимает описание в виде массива, подобно методу `add()` класса @`InputFilter`[Laminas\InputFilter\InputFilter].
Массив имеет ключ "filters", где вы можете зарегистрировать фильтры, которые хотите присоединить к цепи.
Для каждого добавленного фильтра нужно предоставить следующие подключи:

  * "name" - полностью определенное имя фильтра (например, `StringTrim::class`) или его псевдоним (например, "StringTrim");
  * "options"  - массив опций, передаваемых фильтру; и
  * "priority" - опциональный ключ, определяющий приоритет фильтра в цепи. Фильтры с более высоким
    приоритетом используются первыми. Значением по умолчанию для приоритета является `DEFAULT_PRIORITY`.

Наконец, в строке 28 мы вызываем метод `filter()`, который проходит по цепи и передает фильтруемое
значение каждому фильтру по очереди.

### Пользовательская фильтрация с помощью фильтра Callback

Стандартные фильтры предназначены для использования в часто встречающихся ситуациях. Например, вам
часто может понадобиться убрать пробелы из начала и конца строки или преобразовать ее в нижний регистр.
Однако, иногда могут возникнуть случаи, когда вы не можете использовать стандартный фильтр. В таких
ситуациях удобно пользоваться фильтром @`Callback`[Laminas\Filter\Callback].

Фильтр @`Callback`[Laminas\Filter\Callback] разработан как обертка для вашего собственного алгоритма фильтрации. Это может быть
полезно, например, когда вам не подходят стандартные фильтры и к данным необходимо применить свой алгоритм
фильтрации.

I> Пользовательский алгоритм фильтрации реализуется как функция обратного вызова или метод класса обратного вызова.
I> *Механизм обратного вызова* (callback) - это функция или public-метод класса, вызываемый фильтром @`Callback`[Laminas\Filter\Callback], принимающий
I> значение, которое нужно отфильтровать, и (опционально) аргумент(ы), определяемый(-е) пользователем.

Public-методы, предоставляемые фильтром @`Callback`[Laminas\Filter\Callback] перечислены в таблице 8.17.

{title="Table 8.17. Public-методы фильтра Callback"}
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Выполняет функцию обратного вызова в качестве фильтра.        |
|--------------------------------|---------------------------------------------------------------|
| `setCallback($callback)`       | Задает новый механизм обратного вызова для данного фильтра.   |
|--------------------------------|---------------------------------------------------------------|
| `getCallback()`                | Возвращает установленный для фильтра механизм обратного вызова. |
|--------------------------------|---------------------------------------------------------------|
| `setCallbackParams($params)`   | Задает параметры для механизма обратного вызова.              |
|--------------------------------|---------------------------------------------------------------|
| `getCallbackParams()`          | Получает параметры для механизма обратного вызова.            |
|--------------------------------|---------------------------------------------------------------|

Как видите из таблицы, фильтр @`Callback`[Laminas\Filter\Callback] предоставляет методы `setCallback()` и `setCallbackParams()`,
которые можно использовать для задания функции обратного вызова (или метода класса обратного вызова)
и, возможно, передать ей один или несколько параметров.

#### Пример

Чтобы продемонстрировать использование фильтра @`Callback`[Laminas\Filter\Callback], присоединим поле номера телефона
к нашему классу модели формы обратной связи (`ContactForm`) и добавим к нему пользовательский фильтр.

Международный телефонный номер обычно выглядит как "1 (808) 456-7890". Он содержит код страны,
за которым следует код области из трех цифр, заключенных в скобки. Оставшаяся часть номера состоит из
семизначного кода абонента, разделенного на две группы символом тире. Код страны, код области и код
абонента разделены пробелами. В дальнейшем мы будем называть этот телефонный формат "международным" форматом.

Международный телефонный формат необходим для совершения звонков между странами (или областями).
Если звонки делаются внутри одной и той же области, номер телефона может выглядеть как просто "456-7890"
(код страны и код области просто опускаются). Такой формат мы будем называть "локальным" телефонным форматом.

Чтобы сделать наш фильтр как можно более универсальным, предположим, что пользователю необходимо ввести
номер в международном формате в одни формы и в локальном формате в другие.
Так как некоторые посетители сайта могут ввести свой телефонный номер в формате, отличном от требуемого,
мы хотим применить фильтр, который будет "нормализовывать" для нас номер.

Чтобы сделать "нормализацию" номера, фильтр:

 1. Уберет все нечисловые символы из входного значения.
 2. Дополнит значение цифрами до необходимой длины, если цифр слишком мало.
 3. Добавит скобки, пробелы и тире (при использовании международного формата);
    или просто тире (при использовании локального формата).

Так как Laminas не предоставляет стандартных фильтров для выполнения подобной операции фильтрации номера,
мы используем фильтр-обертку @`Callback`[Laminas\Filter\Callback]. Для этого мы внесем следующие изменения в код нашего класса
`ContactForm`:

{line-numbers=on, lang=php}
~~~
<?php
// ...
class ContactForm extends Form
{
  // ...
  protected function addElements()
  {
    // ...

    // Добавляем поле "phone"
    $this->add([
        'type'  => 'text',
        'name' => 'phone',
        'attributes' => [
           'id' => 'phone'
        ],
        'options' => [
           'label' => 'Your Phone',
        ],
     ]);
  }

  private function addInputFilter()
  {
    // ...
    $inputFilter->add([
        'name'     => 'phone',
        'required' => true,
        'filters'  => [
          [
            'name' => 'Callback',
            'options' => [
              'callback' => [$this, 'filterPhone'],
              'callbackParams' => [
                'format' => 'intl'
              ]
            ]
          ],
        ],
      ]);
  }

  // Пользовательский фильтр для номера телефона.
  public function filterPhone($value, $format)
  {
    if(!is_scalar($value)) {
      // Возвращаем нескалярное значение нефильтрованным.
      return $value;
    }

    $value = (string)$value;

    if(strlen($value)==0) {
      // Возвращаем пустое значение нефильтрованным.
      return $value;
    }

    // Сначала удаляем все нечисловые символы.
    $digits = preg_replace('#[^0-9]#', '', $value);

    if($format == 'intl') {
      // Дополняем нулями, если число цифр некорректно.
      $digits = str_pad($digits, 11, "0", STR_PAD_LEFT);

      // Добавляем скобки, пробелы и тире.
      $phoneNumber = substr($digits, 0, 1) . ' ('.
                     substr($digits, 1, 3) . ') ' .
                     substr($digits, 4, 3) . '-'.
                     substr($digits, 7, 4);
    } else { // 'local'
      // Дополняем нулями, если число цифр некорректно.
      $digits = str_pad($digits, 7, "0", STR_PAD_LEFT);

      // Добавляем тире.
      $phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4);
    }

    return $phoneNumber;
  }
}
~~~

В строках 11-20 вышеприведенного фрагмента мы добавляем поле "phone" к модели формы `ContactForm`. Это
поле является обычным текстовым полем ввода, и у нас уже был опыт работы с такими полями.

Затем, в строках 26-40 мы добавляем правило валидации для поля "phone" нашей формы. Под ключом
"filters" (строка 29) мы регистрируем фильтр @`Callback`[Laminas\Filter\Callback] (в данном случае мы используем псевдоним @`Callback`[Laminas\Filter\Callback],
но вы можете вместо этого воспользоваться полностью определенным именем класса `Callback::class`).

Фильтр принимает две опции: "callback" и "callback_params". Опция "callback" - это массив, состоящий из
двух элементов, которые представляют соответственно класс и метод, который нужно вызвать. В этом примере,
механизмом обратного вызова является метод `filterPhone()` класса `ContactForm`. Параметр "format" передается
методу обратного вызова с помощью опции "callbackParams (строка 34).

В строках 44-79 мы определяем метод обратного вызова `filterPhone()`, принимающий два аргумента:
`$value` - номер телефона, который нужно отфильтровать и `$format` - желаемый формат номера.
Параметр `$format` может быть либо `local` (для локального формата), либо `intl` (для международного).

В методе обратного действия `filterPhone()` мы делаем следующее:

  * Сперва, в строке 46 мы проверяем, что параметр `$value` является скалярным значением, а не массивом. Если
    значение не скалярное, мы возвращаем его без изменений.

  * В строке 53 мы проверяем длины входного значения. Если пользователь ввел пустой номер телефона, мы ничего не
    делаем; мы просто возвращаем его как есть.

  * Затем мы удаляем все нецифровые символы (строка 59).

  * Если номер слишком короткий, мы дополняем его нулями.

  * Добавляем скобки, тире и пробелы для международных телефонных номеров;
    либо же просто тире для локальных телефонных номеров.

  * Наконец, мы возвращаем получившийся номер телефона.

Чтобы посмотреть, как работает этот фильтр, можете открыть URL "http://localhost/contactus" в своем браузере.
Если вы введете какой-либо номер телефона в некорректном формате, фильтр исправит номер и преобразует его
в желаемый формат.

## Написание своего собственного фильтра

Альтернативой использования фильтра @`Callback`[Laminas\Filter\Callback] является написание своего собственного класса фильтра,
реализующего интерфейс @`FilterInterface`[Laminas\Filter\FilterInterface]. Фильтр затем можно будет использовать в формах вашего веб-приложения
(или, при желании, вне форм).

Чтобы продемонстрировать создание своего фильтра, мы напишем класс `PhoneFilter`, инкаспулирующий
алгоритм фильтрации номера, который мы использовали в примере фильтра @`Callback`[Laminas\Filter\Callback].

I> Как вы возможно помните, базовым классом для всех стандартных фильтров является класс @`AbstractFilter`.
I> По аналогии мы также будем наследовать наш фильтр `PhoneFilter` от этого базового класса.

Мы планируем иметь следующие методы в классе фильтра `PhoneFilter` (см. таблицу 8.18):

{title="Таблица 8.18. Public-методы PhoneFilter"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор - принимает опциональный аргумент `$options`, который нужен для того, чтобы сразу задать опции фильтра. |
|--------------------------------|---------------------------------------------------------------|
| `setFormat($format)`           | Задает опцию формата номера.                                  |
|--------------------------------|---------------------------------------------------------------|
| `getFormat()`                  | Возвращает опцию формата номера.                              |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Запускает фильтр.                                             |
|--------------------------------|---------------------------------------------------------------|

Сперва создайте файл *PhoneFilter.php* в каталоге *Filter* под
корневым каталогом модуля [^сервис_фильтра_номера]. Поместите в этот файл
следующий код:

[^сервис_фильтра_номера]: Класс `PhoneFilter` можно считать моделью сервиса, так как его задачей является
       обработка данных, а не их хранение. Все пользовательские фильтры принято хранить под каталогом `Filter`.

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Filter;

use Laminas\Filter\AbstractFilter;

// Этот класс фильтра предназначен для преобразования произвольного номера телефона в
// локальный или международный формат.
class PhoneFilter extends AbstractFilter
{
  // Константы форматов номера.
  const PHONE_FORMAT_LOCAL = 'local'; // Local phone format
  const PHONE_FORMAT_INTL  = 'intl';  // International phone format

  // Доступные опции фильтра.
  protected $options = [
    'format' => self::PHONE_FORMAT_INTL
  ];

  // Конструктор.
  public function __construct($options = null)
  {
    // Задает опции фильтра (если они предоставлены).
    if(is_array($options)) {

      if(isset($options['format']))
        $this->setFormat($options['format']);
    }
  }

  // Задает формат номера.
  public function setFormat($format)
  {
    // Проверяет входной аргумент.
    if( $format!=self::PHONE_FORMAT_LOCAL &&
       $format!=self::PHONE_FORMAT_INTL ) {
      throw new \Exception('Invalid format argument passed.');
    }

    $this->options['format'] = $format;
  }

  // Возвращает формат номера.
  public function getFormat()
  {
    return $this->format;
  }

  // Фильтрует телефонный номер.
  public function filter($value)
  {
    if(!is_scalar($value)) {
      // Возвращаем нескалярное значение неотфильтрованным.
      return $value;
    }

    $value = (string)$value;

    if(strlen($value)==0) {
      // Возвращаем пустое значение неотфильтрованным.
      return $value;
    }

    // Сперва удаляем все нецифровые символы.
    $digits = preg_replace('#[^0-9]#', '', $value);

    $format = $this->options['format'];

    if($format == self::PHONE_FORMAT_INTL) {
      // Дополняем нулями, если число цифр некорректно.
      $digits = str_pad($digits, 11, "0", STR_PAD_LEFT);

      // Добавляем скобки, пробелы и тире.
      $phoneNumber = substr($digits, 0, 1) . ' (' .
                     substr($digits, 1, 3) . ') ' .
                     substr($digits, 4, 3) . '-' .
                     substr($digits, 7, 4);
    } else { // self::PHONE_FORMAT_LOCAL
      // Дополняем нулями, если число цифр некорректно
      $digits = str_pad($digits, 7, "0", STR_PAD_LEFT);

      // Добавляем тире.
      $phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4);
    }

    return $phoneNumber;
  }
}
~~~

Как видите из строки 2 класс фильтра содержится в пространстве имен `Application\Filter`.

В строке 8 мы определяем класс `PhoneFilter`. Мы наследуем наш фильтр от базового класса
@`AbstractFilter` для повторного использования предоставляемой им функциональности. Строка 4
содержит псевдоним для класса @`AbstractFilter`.

В строках 11-12 мы для удобства определяем константы форматов номера (`PHONE_FORMAT_INTL` для
международного формата и `PHONE_FORMAT_LOCAL` для локального). Эти константы - эквиваленты
строк "intl" и "local" соответственно.

В строках 15-17 мы определяем private-переменную `$options`, которая является массивом, имеющим
один единственный ключ под названием "format". Этот ключ будет содержать опцию формата номера для
нашего фильтра.

В строках 20-28 находится метод конструктора, который принимает один аргумент `$options`.
При создании фильтра вручную, этот параметр можно пропустить. Однако, когда фильтр создается
классом фабрики, фабрика будет передавать опции фильтра его конструктору через этот аргумент.

В строках 31-40 и 43-46 находятся методы `setFormat()` и `getFormat()`, позволяющие соответственно
задать и извлечь текущий формат номера.

В строках 49-86 находится метод `filter()`. Этот метод инкапсулирует алгоритм фильтрации телефонного
номера. Он принимает параметр `$value`, преобразовывает его с учетом выбранного формата номера
и возвращает отформатированный номер телефона.

### Использование класса PhoneFilter

Как только класс фильтра `PhoneFilter` будет готов, вы легко можете начать его использовать в
форме обратной связи (или других формам) как показано ниже. Предполагается, что вы вызываете
следующий код внутри метода `ContactForm::addInputFilter()`:

~~~php
$inputFilter->add([
      'name'     => 'phone',
      'required' => true,
      'filters'  => [
        [
          'name' => PhoneFilter::class,
          'options' => [
            'format' => PhoneFilter::PHONE_FORMAT_INTL
          ]
        ],
        // ...
      ],
      // ...
    ]);
~~~

Вы можете посмотреть, как работает фильтр `PhoneFilter` в примере *Form Demo* - приложении, которое идет
вместе с этой книгой. Откройте страницу "http://localhost/contactus" в своем браузере. Если вы введете
какой-либо телефонный номер в некорректном формате, фильтр исправит номер.

Если хотите, можете использовать `PhoneFilter` вне форм, как показано во фрагменте кода ниже:

~~~php
<?php
use Application\Filter\PhoneFilter;

// Создаем фильтр PhoneFilter.
$filter = new PhoneFilter();

// Настраиваем фильтр.
$filter->setFormat(PhoneFilter::PHONE_FORMAT_INTL);

// Фильтруем строку.
$filteredValue = $filter->filter('12345678901');

// Ожидаемый вывод фильтра - '1 (234) 567-8901'.
~~~

## Выводы

Фильтры предназначены для приема входных данных, их обработки, а затем создания выходных данных.
Laminas Framework предоставляет множество стандартных фильтров, которые можно использовать для
создания правил фильтрации ваших форм (или, если хотите, чтобы отфильтровать произвольные данные вне форм).

Стандартные фильтры можно приблизительно разделить на следующие группы:

 * Фильтры для приведения входных данных к определенному типу;
 * фильтры, выполняющие манипуляции с путем к файлу;
 * фильтры, осуществляющие сжатие и шифрование входных данных;
 * фильтры, управляющие строковыми данными; и
 * фильтры-заместители - обертки для других фильтров.

Если стандартные фильтры не подходят, вы можете создать свой класс фильтра.
В этой главе мы привели пример того, как написать собственный класс `PhoneFilter`,
способный фильтровать телефонные номера.
